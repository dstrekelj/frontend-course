# Frontend Course / Essential Git / Version Control With Git Repositories

[:arrow_backward: Frontend Course / Essential Git](./README.md)

---

## Version Control

**Version control** is the practice of keeping track of changes made to data. A **version control system (VCS)** is software that tracks and manages changes made to data on behalf of the user. Word processors such as Microsoft Word, for example, use a type of VCS to track the history of changes made to the document.

In the world of software development, the VCS tracks changes made to the files of a software project in a database called a **repository**. Every change stored in a repository is called a **commit** - as in, a change was committed to the project files.

A VCS can be either centralised or distributed. **Centralised VCS** host the repository on a server that client computers connect to in order to push and pull changes from the repository. **Distributed VCS** opt for every computer to have its own copy of the repository that the computers then synchronise between themselves in a network of peers.

> :point_up: **Note!** The peer-to-peer approach of a distributed VCS means users can work offline, privately, and not worry about losing data since backups are a positive side-effect of everyone having a copy of the repository. However, distributed VCS also require more storage space on the user's computer and may pose a security risk due to code base exposure - again, a side effect of everyone having a copy of the repository.

## Git

Our VCS of choice will be **Git** - a free, open source, and widely available distributed VCS. Although others exist (such as Subversion and Mercurial), Git has become the de facto standard for the software industry. Git works best on plain text files where it can tell which lines in the file have changed between versions. In case of binary file formats such as images and videos, Git opts to completely replace the old version with thew version of the file.

> :point_up: **Note!** From this point on, we will discuss version control as it is handled by Git. Terminology and implementation details may differ between different VCS, but the general idea is roughly the same.

Git differentiates between tracked and untracked files. **Tracked files** are files that were at some point stored in the repository. **Untracked files** are files that were not yet stored in the repository. Git can only version tracked files because the repository then contains reference points for changes between file versions.

Files are tracked by committing them to the repository. A **commit** contains one or more changes made to tracked files, along with a commit message and a bundle of useful information such as the author of the change, the time and date of the change, and a unique hash ID of the change called the **commit hash**.

Every commmit represents a snapshot of a state in which the repository was recorded to be at a set point in time. The commit that represents the currently observed repository state is called the **HEAD** commit.

A **Git repository** stores commits in a tree-like fashion where every commit belongs to a **branch**. To continue the analogy, the **trunk** of the tree is commonly called the **master branch** - the "masterwork" or latest (usually stable) state of the project - and represents the branch from which all other branches are made.

An example commit:

```
commit 3885d0486081028962f580eef0f08ddb6804d2a0 (HEAD -> master)
Author: John Doe <john.doe@example.com>
Date:   Sat Jul 23 13:05:12 2022 +0200

    Initial commit
```

In this example:

- the commit hash is `3885d0486081028962f580eef0f08ddb6804d2a0`
- the current branch is `master`, this is where the `HEAD` is located
- the commit author is `John Doe` and the author's contact email is `john.doe@example.com`
- the commit date and time is `Sat Jul 23 13:05:12 2022 +0200`
- the commit message is `Initial commit`

### Initialising a Git repository

To initialise a Git repository, we open our project folder in a terminal application and run:

```sh
git init
```

`git init` creates a hidden `.git` folder at the current working directory. The `.git` folder is home to the repository and additional Git configurations. If we remove the `.git` folder and we will remove the repository, along with the entire history of tracked changes we had up until that point.

To check the status of an initialised repository run:

```sh
git status
```

An example status:

```
On branch master

nothing to commit, working tree clean
```

`git status` is useful to check on the state of the project repository, new files that have yet to be tracked, or tracked files that have been modified or deleted.

### Tracking files in the repository through commits

Create a new empty file with the name `README.md` in the root of the project folder. `git status` will report the change accordingly:

```
On branch master

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        README.md

nothing added to commit but untracked files present (use "git add" to track)
```

As Git itself suggets, we can track the new file with `git add <file>`:

```
git add README.md
```

`git add` accepts one or more multiple paths to files or folders we want to track. For example, `git add .` would recursively add all of the files and folders in the current working directory to the commit.

Running `git status` now shows that the new file is staged and ready to be committed:

```
On branch master

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   README.md
```

Files that were staged can be unstaged with `git restore --staged <file>`. Unstaging a file only affects whether that version of the file will be present in the commit; the changes in the file are not reverted.

We can commit files once we've staged them:

```
git commit
```

`git commit` will open a text editor for us to enter a commit message in. Commit messages should be short and descriptive, finishing the statement _"When applied, this commit will..."_. For example, `Add README file`.

We can also use the `--message "<text>"` (or `-m "<text>"`) option to write a commit message directly in the terminal:

```
git commit --message "Add README file"
```

> :point_up: **Note!** Git can be configured to use a specific text editor for writing commit messages. See the [official documentation](https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration) for more information.

Following a successful commit, Git will inform us of the changes recorded to the repository:

```
[master 013b99b] Add README file
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 README.md
```

In this case:

- A new commit was created on the `master` branch
- The first 7 characters of the commit hash are `013b99b`
- The commit message was `Add README file`
- 1 file was changed, with 0 lines inserted or deleted
- As part of this commit, the `README.md` file was created with permissions `100644`

> :point_up: **Homework!** `100644` is a Unix-style permission indicator describing the read, write, and execute permission levels that an owner, group of owners, or guest user has over a file. Research how the permission indicator is constructed. What does `100644` represent?

### Reviewing the commit history

We can check the history of commits in the repository with:

```
git log
```

`git log` lists all commits stored in the repository including their commit hash, author, date, and commit message:

```
commit 013b99b1eeb83f56ab379088dc96d0502d71b1e4 (HEAD -> master)
Author: John Doe <john.doe@example.com>
Date:   Sun Jul 24 10:50:39 2022 +0200

    Add README file
```

> :point_up: **Homework!** Git provides options to refine the results of `git log`. Research the [official documentation](https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History). How can we list commits so that we only see the abbreviated commit hash and subject?

### Removing tracked files from the repository

We may accidentally commit files that we did not intend to commit, making them tracked by the Git repository. We can untrack these files by removing them from the Git repository:

```
git rm README.md
```

`git rm <file>` deletes the file from the filesystem, removes it from the Git repository cache, and stages the change for the next commit. The change can always be discarded by restoring the file with `git restore`.

We can also remove the file only from the Git repository cache using `git rm --cached <file>`. In this case, the file remains on the filesystem, but Git considers it to be deleted from the repository from that commit onward.

> :point_up: **Note!** Removing a tracked file from the Git repository does not remove it from commits in the repository's history. Removing a file from the repository's history requires the entire commit history to be filtered and rewritten. Rewritting the commit history is a dangerous and error-prone task, especially if the file in question is historically used throughout the project. As a general rule, we should never commit sensitive data to a repository.

---

[:arrow_backward: Frontend Course / Essential Git](./README.md)
